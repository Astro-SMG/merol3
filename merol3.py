'''########################################################################################################################################################################################################################################################################################## This program interpolates stellar parameters (Teff, log G and [Fe/H] from a set of stellar templates. 3-diMensional spEctral stellaR interpOLator (merol3)  Author  S. Meneses-Goytia (SMG) History  Version 1.00 | 2009 | Kapteyn Instituut - RUG, Groningen, NL    FORTRAN version - sigmac.f90    Developed from the Vazdekis et al. FORTRAN stellar interpolator for SSP models        - reponse curves for NIR filters added    - several bugs solved regarding the weights of the templates used      Version 2.00 | 2010-2015 | Kapteyn Instituut - RUG, Groningen, NL    IDL version - sigmac.pro    The full code was translated and adapted to work in IDL        - in resp_ routines: hunt and polint were substituted by IDL where and interpol function    - fortran indexx: replaced by IDL sort function  Version 3.00 | 2018 | Institute of Cosmology and Gravitation - UoP, Portsmouth, UK    PyTHON version - merol3.py    The full code was adapted and simplified to work in Python        - an intrinsic routine that prepares the templates to be used: prepare_templates    - grid routine added to create a denser grid using only physical stars for any set of templates: make_full_hrd_grid    - grid routine added to create a denser selected grid for any set of templates: make_selected_grid    - the cube builder has been added as a separate routine: get_qb    - an additional routine to create one single synthetic star is presented: single_star ############################################################################################################################################# #############################################################################################################################################'''import sysimport numpy as npfrom numpy import linspace, zeros, arrayfrom astropy.io import fitsfrom matplotlib import cmimport scipy.interpolate as spintfrom scipy.interpolate import griddatafrom calculate_magnitudes import *from calculate_indices import *import timeimport datetime'''##########################################################################################################################################################################################################################################################################################'''class merol3:  def __init__(self,templates_info,templates_dir,output_dir):    self.templates_info = templates_info    self.templates_dir  = templates_dir    self.output_dir     = output_dir#############################################################################################################################################    def get_qb(self,in1,in2,in3):    ax1=self.templates_parameters[:,0]    ax2=self.templates_parameters[:,1]    ax3=self.templates_parameters[:,2]    uu = np.unique(ax2)    diff = np.absolute(uu-in2)    difflogg=diff.argsort()[:2]    instep=[0,-1,1] #try 3 logg steps    instep2=[0,-1,1,-2,2] #try 5 teff steps    for ss in instep:      ind=np.sort(difflogg+ss)      if(ind[0] < 0): ind[0] = 0      if(ind[0] > len(uu)-1): ind[0] = len(uu)-1      if(ind[1] < 0): ind[1] = 0      if(ind[1] > len(uu)-1): ind[1] = len(uu)-1      ax2s = uu[ind]      covlogg,=np.where((ax2>=ax2s[0]) & (ax2<=ax2s[1]) )      if covlogg.size:        vv = np.unique(ax1[covlogg])        diff = np.absolute(vv-in1)        diffteff=diff.argsort()[:2]        for tt in instep2:          ind=np.sort(diffteff+tt)          #print(ind,tt)          if(ind[0] < 0): ind[0]=0          if(ind[0] > len(vv)-1): ind[0] = len(vv)-1          if(ind[1] < 0): ind[1]=0          if(ind[1] > len(vv)-1): ind[1] = len(vv)-1          #print(ind)          ax1s = vv[ind]          covteff,=np.where((ax1>=ax1s[0]) & (ax1<=ax1s[1]) & (ax2>=ax2s[0]) & (ax2<=ax2s[1]) )          if covteff.size:            unife = np.unique(ax3)            num_fe, bins_fe = np.histogram(ax3[covteff], bins=unife)            fullfe,=np.where(num_fe >= 4)            diff = np.absolute(bins_fe[fullfe]-in3)            ax3s = bins_fe[fullfe[diff.argsort()]][:2]            check = np.in1d(ax1,ax1s) & np.in1d(ax2,ax2s) & np.in1d(ax3,ax3s)            if(np.sum(check) >= 8):              points = np.vstack((ax1[check], ax2[check], ax3[check]))              vals = np.vstack(self.templates_flux[check,:])              return points.T,vals.T    raise ValueError('          > no valid vertices found')    #############################################################################################################################################  def prepare_templates(self):      print('     > preparing templates')    templates = fits.open(self.templates_info)    #print(templates[1].header)    templates_id = templates[1].data['name']    ntemp = int(len(templates_id))    templates_parameters = np.zeros((ntemp,3))    templates_parameters[:,0] = templates[1].data['teff']    templates_parameters[:,1] = templates[1].data['logg']    templates_parameters[:,2] = templates[1].data['metal']    templates_id = templates_id.flatten()    ##### templates limits #####    lim_tefflow  = min(templates_parameters[:,0])    lim_teffhigh = max(templates_parameters[:,0])     lim_logglow  = min(templates_parameters[:,1])    lim_logghigh = max(templates_parameters[:,1])     lim_fehlow   = min(templates_parameters[:,2])    lim_fehhigh  = max(templates_parameters[:,2])    '''    print('     > templates limits:')    print('          > min Teff  = '+str(lim_tefflow))    print('          > max Teff  = '+str(lim_teffhigh))    print('          > min logg  = '+str(lim_logglow))    print('          > max logg  = '+str(lim_logghigh))    print('          > min [Z/H] = '+str(lim_fehlow))    print('          > max [Z/H]  = '+str(lim_fehhigh))    '''      '''    ##### grid steps #####     teffstep = 100.    loggstep = 0.1    fehstep  = 0.1    ##### quality limits #####    tefflim = 100.    logglim = 0.1    fehlim  = 0.1    '''    #print('     > total number of templates = '+str(ntemp))    test = fits.open(self.templates_dir+templates_id[0]+'.fits')    naxis1 = int(test[0].header['NAXIS1'])    crval1 = test[0].header['CRVAL1']    crval2 = test[0].header['CRVAL2']    cdelt1 = test[0].header['CDELT1']    wave = np.linspace(start=crval1,stop=crval2,num=naxis1)    #print('     > total number of pixels = '+str(naxis1))    templates_flux = np.zeros((ntemp,naxis1))    for i in range(0,ntemp):      template = fits.open(self.templates_dir+templates_id[i]+'.fits')      templates_flux[i,:] = template[0].data      sys.stdout.write("          > template = %d %s \r" % (i+1,'done'))      sys.stdout.flush()    sys.stdout.flush()    print(' ')    print('     > all templates uploaded')          self.crval1 = crval1    self.crval2 = crval2    self.cdelt1 = cdelt1    self.wave = wave    self.ntemp = ntemp          self.templates_parameters = templates_parameters    self.templates_flux = templates_flux    '''    self.tefflow = tefflow    self.teffhigh = teffhigh    self.teffstep = teffstep    self.tefflim = tefflim    self.logglow = logglow    self.logghigh = logghigh    self.loggstep = loggstep    self.logglim = logglim    self.fehlow = fehlow    self.fehhigh = fehhigh    self.fehstep = fehstep     self.fehlim = fehlim        '''       #############################################################################################################################################  def make_full_hrd_grid(self):    ##### setting up some variables for magnitudes and indices calculation #####    filter_list = 'combo_sdss_gaia.res' #'sdss_manga_pipeline.res'    zero_point = 'AB'    redshift = 0.0    indices_list = 'MaNGA_range.def'      print('     > creating a denser full HRd grid')    ##### 11 boxes #####    nboxes = 11    ntemp_per_box = np.full(nboxes,1)    #tefflow  = [2500,2500,2800, 4000, 4600,15300, 4000,3400,3100,2800,2600]    #teffhigh = [4300,7700,7700,15300,15300,35000,12400,9300,7000,6300,4600]    tefflow  = [2400,2400,2400, 2400, 2400,15300, 2400,2400,2400,2400,2400]    teffhigh = [4300,7700,7700,15300,15300,35000,12400,9300,7000,6300,4600]    teffstep = [ 100, 100, 100,  250,  250,  500,  250, 100, 100, 100, 100]     teffqual = [ 100, 100, 100,  250,  250,  500,  250, 100, 100, 100, 100] #np.full(nboxes,100)    logglow  = [5.1,4.8,4.5,3.8,2.9,2.9,1.9,0.9,0.2,-0.1,-0.5]    logghigh = [5.5,5.1,4.8,4.5,3.9,4.5,2.9,1.9,0.9, 0.2,-0.1]    loggstep = [0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1, 0.1, 0.1]    loggqual = [0.2,0.2,0.2,0.1,0.1,0.2,0.1,0.1,0.1, 0.1, 0.1] #np.full(nboxes,0.1)    fehlow  = [-2.5,-2.5,-2.5,-2.5,-2.5,-2.5,-2.5,-2.5,-2.5,-2.5,-2.5]    fehhigh = [ 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6]    fehstep = [ 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]    fehqual = [ 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2] #np.full(nboxes,0.1)    for b in range(0,nboxes):      ##### set up a regular output grid #####      teffvals = np.arange(tefflow[b],teffhigh[b],teffstep[b])      loggvals = np.arange(logglow[b],logghigh[b],loggstep[b])      fehvals = np.arange(fehlow[b],fehhigh[b],fehstep[b])      X,Y,Z = np.meshgrid(teffvals,loggvals,fehvals)            temps_per_box = (np.vstack((X.ravel(),Y.ravel(),Z.ravel()))).T      ntemp_per_box[b] = int(temps_per_box.shape[0])      if(b == 0):        templates_outpars = temps_per_box        tefflim = np.full(ntemp_per_box[b],teffqual[b])        logglim = np.full(ntemp_per_box[b],loggqual[b])        fehlim  = np.full(ntemp_per_box[b],fehqual[b])      else:        templates_outpars = np.vstack((templates_outpars,temps_per_box))        tefflim           = np.append(tefflim,np.full(ntemp_per_box[b],teffqual[b]))        logglim           = np.append(logglim,np.full(ntemp_per_box[b],loggqual[b]))        fehlim            = np.append(fehlim,np.full(ntemp_per_box[b],fehqual[b]))    ntempout = np.sum(ntemp_per_box)    indices = np.zeros((ntempout,42))    mags = np.zeros((ntempout,8))    print('     > total number of output templates = '+str(ntempout))    ##### quality flag to each grid point #####    templates_quality = np.zeros(ntempout)    fits_name = np.chararray(ntempout,10)    dist_temp = np.zeros((self.ntemp,3))    for i in range(0,ntempout):      pars_star = templates_outpars[i,:]      ndim = len(pars_star)          ##### find the 8 vertices for interpolation #####      vertices,vals = self.get_qb(*pars_star)          ##### tri-linear interpolation #####      for dim in xrange(ndim):        vtx_delta = 2**(ndim - dim - 1)        for vtx in xrange(vtx_delta):          vals[vtx,:] += ((vals[vtx+vtx_delta,:]-vals[vtx,:])*(pars_star[dim]-vertices[vtx,dim])/(vertices[vtx+vtx_delta,dim]-vertices[vtx,dim]))      ##### need to transpose the values #####      flux_per_pixel = vals[:,0]      bad_flux = np.isnan(flux_per_pixel) | np.isinf(flux_per_pixel) | (flux_per_pixel <= 0.0)      flux_per_pixel[bad_flux] = 0.0      ##### quality checks #####      dist_temp[:,0] = np.abs(pars_star[0]-self.templates_parameters[:,0])      dist_temp[:,1] = np.abs(pars_star[1]-self.templates_parameters[:,1])      dist_temp[:,2] = np.abs(pars_star[2]-self.templates_parameters[:,2])      good = np.where((dist_temp[:,0] <= tefflim[i]) & (dist_temp[:,1] <= logglim[i]) & (dist_temp[:,2] <= fehlim[i]))[0]      if len(good)>=1:        templates_quality[i] = 1      fits_name[i] = 'grid'+str(i).zfill(6)      ##### calculating indices within the MaNGA wavelength range #####      indices[i,:], err_indices = calculate_indices(self.wave,flux_per_pixel*1e-17,indices_list,fits_name[i],ef=0,rv=0,plot=False,sim=False)      ######## calculating the magnitudes ########      mags[i,:] = calculate_magnitudes(self.wave,flux_per_pixel*1e-17,filter_list,zero_point,redshift)          hdu = fits.PrimaryHDU()      hdu.header['CRVAL1'] = self.crval1      hdu.header['CRVAL2'] = self.crval2      hdu.header['CDELT1'] = self.cdelt1      hdu.header['TEFF'] = templates_outpars[i,0]      hdu.header['LOGG'] = templates_outpars[i,1]      hdu.header['METAL'] = templates_outpars[i,2]      hdu.header['QUALITY'] = templates_quality[i]      hdu.data = flux_per_pixel/np.median(flux_per_pixel)      hdu.writeto(self.output_dir+'grid/'+fits_name[i]+'.fits',clobber=True)      sys.stdout.write("          > artifical star = %d %s \r" % (i+1,'done'))      sys.stdout.flush()    sys.stdout.flush()    print(' ')    print('     > all stars uploaded')    tbhdu = fits.BinTableHDU.from_columns([fits.Column(name='NAME', array=np.array(fits_name[:]), format='20A'),                                           fits.Column(name='TEFF', array=np.array(templates_outpars[:,0]),format='D'),                                           fits.Column(name='LOGG', array=np.array(templates_outpars[:,1]),format='D'),                                           fits.Column(name='METAL', array=np.array(templates_outpars[:,2]),format='D'),                                           fits.Column(name='QUALITY', array=np.array(templates_quality[:]),format='J'),                                           fits.Column(name='Umag', array=np.array(mags[:,0]), format='D'),                                           fits.Column(name='Gmag', array=np.array(mags[:,1]), format='D'),                                           fits.Column(name='Rmag', array=np.array(mags[:,2]), format='D'),                                           fits.Column(name='Imag', array=np.array(mags[:,3]), format='D'),                                           fits.Column(name='Zmag', array=np.array(mags[:,4]), format='D'),                                           fits.Column(name='gggmag', array=np.array(mags[:,5]), format='D'),                                           fits.Column(name='gbpmag', array=np.array(mags[:,6]), format='D'),                                           fits.Column(name='grpmag', array=np.array(mags[:,7]), format='D'),                                           fits.Column(name='OII3727', array=np.array(indices[:,0]), format='D'),                                           fits.Column(name='HdA', array=np.array(indices[:,1]), format='D'),                                           fits.Column(name='HdF', array=np.array(indices[:,2]), format='D'),                                           fits.Column(name='CN1', array=np.array(indices[:,3]), format='D'),                                           fits.Column(name='CN2', array=np.array(indices[:,4]), format='D'),                                           fits.Column(name='Ca4227', array=np.array(indices[:,5]), format='D'),                                           fits.Column(name='G4300', array=np.array(indices[:,6]), format='D'),                                           fits.Column(name='HgA', array=np.array(indices[:,7]), format='D'),                                           fits.Column(name='HgF', array=np.array(indices[:,8]), format='D'),                                           fits.Column(name='Fe4383', array=np.array(indices[:,9]), format='D'),                                           fits.Column(name='Ca4455', array=np.array(indices[:,10]), format='D'),                                           fits.Column(name='Fe4531', array=np.array(indices[:,11]), format='D'),                                           fits.Column(name='Fe4668', array=np.array(indices[:,12]), format='D'),                                           fits.Column(name='Hbeta', array=np.array(indices[:,13]), format='D'),                                           fits.Column(name='Hbetap', array=np.array(indices[:,14]), format='D'),                                           fits.Column(name='OIII1', array=np.array(indices[:,15]), format='D'),                                           fits.Column(name='OIII2', array=np.array(indices[:,16]), format='D'),                                           fits.Column(name='Fe5015', array=np.array(indices[:,17]), format='D'),                                           fits.Column(name='Mg1', array=np.array(indices[:,18]), format='D'),                                           fits.Column(name='Mg2', array=np.array(indices[:,19]), format='D'),                                           fits.Column(name='Mgb5177', array=np.array(indices[:,20]), format='D'),                                           fits.Column(name='Fe5270', array=np.array(indices[:,21]), format='D'),                                           fits.Column(name='Fe5335', array=np.array(indices[:,22]), format='D'),                                           fits.Column(name='Fe5406', array=np.array(indices[:,23]), format='D'),                                           fits.Column(name='Fe5709', array=np.array(indices[:,24]), format='D'),                                           fits.Column(name='Fe5782', array=np.array(indices[:,25]), format='D'),                                           fits.Column(name='NaD', array=np.array(indices[:,26]), format='D'),                                           fits.Column(name='TiO1', array=np.array(indices[:,27]), format='D'),                                           fits.Column(name='TiO2', array=np.array(indices[:,28]), format='D'),                                           fits.Column(name='NaILaB', array=np.array(indices[:,29]), format='D'),                                           fits.Column(name='NaISp', array=np.array(indices[:,30]), format='D'),                                           fits.Column(name='NaICo', array=np.array(indices[:,31]), format='D'),                                           fits.Column(name='Ca1', array=np.array(indices[:,32]), format='D'),                                           fits.Column(name='Ca2', array=np.array(indices[:,33]), format='D'),                                           fits.Column(name='Ca3', array=np.array(indices[:,34]), format='D'),                                           fits.Column(name='MgI', array=np.array(indices[:,35]), format='D'),                                           fits.Column(name='Ca1AZ', array=np.array(indices[:,36]), format='D'),                                           fits.Column(name='Ca2AZ', array=np.array(indices[:,37]), format='D'),                                           fits.Column(name='Ca3AZ', array=np.array(indices[:,38]), format='D'),                                           fits.Column(name='CaT', array=np.array(indices[:,39]), format='D'),                                           fits.Column(name='PaT', array=np.array(indices[:,40]), format='D'),                                           fits.Column(name='sCaT', array=np.array(indices[:,41]), format='D')                                           ])        tbhdu.writeto(self.output_dir+'templates_grid_parameters_R2000_sdss_gaia.fits',clobber=True)    print('     > output file done')#############################################################################################################################################  def make_selected_grid(self,teff_info,logg_info,feh_info):      ##### setting up some variables for magnitudes and indices calculation #####    filter_list = 'combo_sdss_gaia.res' #'sdss_manga_pipeline.res'    zero_point = 'AB'    redshift = 0.0    indices_list = 'MaNGA_range.def'    print('     > creating a denser grid')    tefflow  = teff_info[0]    teffhigh = teff_info[1]    teffstep = teff_info[2]    teffqual = teff_info[3]    logglow  = logg_info[0]    logghigh = logg_info[1]    loggstep = logg_info[2]    loggqual = logg_info[3]    fehlow   = feh_info[0]    fehhigh  = feh_info[1]    fehstep  = feh_info[2]    fehqual  = feh_info[3]        ##### set up a regular output grid #####    teffvals = np.arange(tefflow,teffhigh,teffstep)    loggvals = np.arange(logglow,logghigh,loggstep)    fehvals = np.arange(fehlow,fehhigh,fehstep)    X,Y,Z = np.meshgrid(teffvals,loggvals,fehvals)        templates_outpars = (np.vstack((X.ravel(),Y.ravel(),Z.ravel()))).T    ntempout = int(templates_outpars.shape[0])    tefflim.append(np.full(ntempout,teffqual))    logglim.append(np.full(ntempout,loggqual))    fehlim.append(np.full(ntempout,fehqual))    indices = np.zeros((ntempout,42))    mags = np.zeros((ntempout,8))    print('     > total number of output templates = '+str(ntempout))    ##### quality flag to each grid point #####    templates_quality = np.zeros(ntempout)    fits_name = np.chararray(ntempout,10)    dist_temp = np.zeros((self.ntemp,3))    for i in range(0,ntempout):      pars_star = templates_outpars[i,:]      print(pars_star)      ndim = len(pars_star)          ##### find the 8 vertices for interpolation #####      vertices,vals = self.get_qb(*pars_star)          ##### tri-linear interpolation #####      for dim in xrange(ndim):        vtx_delta = 2**(ndim - dim - 1)        for vtx in xrange(vtx_delta):          vals[vtx,:] += ((vals[vtx+vtx_delta,:]-vals[vtx,:])*(pars_star[dim]-vertices[vtx,dim])/(vertices[vtx+vtx_delta,dim]-vertices[vtx,dim]))      ##### need to transpose the values #####      flux_per_pixel = vals[:,0]      bad_flux = np.isnan(flux_per_pixel) | np.isinf(flux_per_pixel) | (flux_per_pixel <= 0.0)      flux_per_pixel[bad_flux] = 0.0      ##### quality checks #####      dist_temp[:,0] = np.abs(pars_star[0]-self.templates_parameters[:,0])      dist_temp[:,1] = np.abs(pars_star[1]-self.templates_parameters[:,1])      dist_temp[:,2] = np.abs(pars_star[2]-self.templates_parameters[:,2])      good = np.where((dist_temp[:,0] <= tefflim[i]) & (dist_temp[:,1] <= logglim[i]) & (dist_temp[:,2] <= fehlim[i]))[0]      if len(good)>=1:        templates_quality[i] = 1      fits_name[i] = 'grid'+str(i).zfill(6)      ##### calculating indices within the MaNGA wavelength range #####      indices[i,:], err_indices = calculate_indices(self.wave,flux_per_pixel*1e-17,indices_list,fits_name[i],ef=0,rv=0,plot=False,sim=False)      ######## calculating the magnitudes ########      mags[i,:] = calculate_magnitudes(self.wave,flux_per_pixel*1e-17,filter_list,zero_point,redshift)          hdu = fits.PrimaryHDU()      hdu.header['CRVAL1'] = self.crval1      hdu.header['CRVAL2'] = self.crval2      hdu.header['CDELT1'] = self.cdelt1      hdu.header['TEFF'] = templates_outpars[i,0]      hdu.header['LOGG'] = templates_outpars[i,1]      hdu.header['METAL'] = templates_outpars[i,2]      hdu.header['QUALITY'] = templates_quality[i]      hdu.data = flux_per_pixel/np.median(flux_per_pixel)      hdu.writeto(self.output_dir+'grid/'+fits_name[i]+'.fits',clobber=True)      sys.stdout.write("          > artifical star = %d %s \r" % (i+1,'done'))      sys.stdout.flush()    sys.stdout.flush()    print(' ')    print('     > all stars uploaded')    tbhdu = fits.BinTableHDU.from_columns([fits.Column(name='NAME', array=np.array(fits_name[:]), format='20A'),                                           fits.Column(name='TEFF', array=np.array(templates_outpars[:,0]),format='D'),                                           fits.Column(name='LOGG', array=np.array(templates_outpars[:,1]),format='D'),                                           fits.Column(name='METAL', array=np.array(templates_outpars[:,2]),format='D'),                                           fits.Column(name='QUALITY', array=np.array(templates_quality[:]),format='J'),                                           fits.Column(name='Umag', array=np.array(mags[:,0]), format='D'),                                           fits.Column(name='Gmag', array=np.array(mags[:,1]), format='D'),                                           fits.Column(name='Rmag', array=np.array(mags[:,2]), format='D'),                                           fits.Column(name='Imag', array=np.array(mags[:,3]), format='D'),                                           fits.Column(name='Zmag', array=np.array(mags[:,4]), format='D'),                                           fits.Column(name='gggmag', array=np.array(mags[:,5]), format='D'),                                           fits.Column(name='gbpmag', array=np.array(mags[:,6]), format='D'),                                           fits.Column(name='grpmag', array=np.array(mags[:,7]), format='D'),                                           fits.Column(name='OII3727', array=np.array(indices[:,0]), format='D'),                                           fits.Column(name='HdA', array=np.array(indices[:,1]), format='D'),                                           fits.Column(name='HdF', array=np.array(indices[:,2]), format='D'),                                           fits.Column(name='CN1', array=np.array(indices[:,3]), format='D'),                                           fits.Column(name='CN2', array=np.array(indices[:,4]), format='D'),                                           fits.Column(name='Ca4227', array=np.array(indices[:,5]), format='D'),                                           fits.Column(name='G4300', array=np.array(indices[:,6]), format='D'),                                           fits.Column(name='HgA', array=np.array(indices[:,7]), format='D'),                                           fits.Column(name='HgF', array=np.array(indices[:,8]), format='D'),                                           fits.Column(name='Fe4383', array=np.array(indices[:,9]), format='D'),                                           fits.Column(name='Ca4455', array=np.array(indices[:,10]), format='D'),                                           fits.Column(name='Fe4531', array=np.array(indices[:,11]), format='D'),                                           fits.Column(name='Fe4668', array=np.array(indices[:,12]), format='D'),                                           fits.Column(name='Hbeta', array=np.array(indices[:,13]), format='D'),                                           fits.Column(name='Hbetap', array=np.array(indices[:,14]), format='D'),                                           fits.Column(name='OIII1', array=np.array(indices[:,15]), format='D'),                                           fits.Column(name='OIII2', array=np.array(indices[:,16]), format='D'),                                           fits.Column(name='Fe5015', array=np.array(indices[:,17]), format='D'),                                           fits.Column(name='Mg1', array=np.array(indices[:,18]), format='D'),                                           fits.Column(name='Mg2', array=np.array(indices[:,19]), format='D'),                                           fits.Column(name='Mgb5177', array=np.array(indices[:,20]), format='D'),                                           fits.Column(name='Fe5270', array=np.array(indices[:,21]), format='D'),                                           fits.Column(name='Fe5335', array=np.array(indices[:,22]), format='D'),                                           fits.Column(name='Fe5406', array=np.array(indices[:,23]), format='D'),                                           fits.Column(name='Fe5709', array=np.array(indices[:,24]), format='D'),                                           fits.Column(name='Fe5782', array=np.array(indices[:,25]), format='D'),                                           fits.Column(name='NaD', array=np.array(indices[:,26]), format='D'),                                           fits.Column(name='TiO1', array=np.array(indices[:,27]), format='D'),                                           fits.Column(name='TiO2', array=np.array(indices[:,28]), format='D'),                                           fits.Column(name='NaILaB', array=np.array(indices[:,29]), format='D'),                                           fits.Column(name='NaISp', array=np.array(indices[:,30]), format='D'),                                           fits.Column(name='NaICo', array=np.array(indices[:,31]), format='D'),                                           fits.Column(name='Ca1', array=np.array(indices[:,32]), format='D'),                                           fits.Column(name='Ca2', array=np.array(indices[:,33]), format='D'),                                           fits.Column(name='Ca3', array=np.array(indices[:,34]), format='D'),                                           fits.Column(name='MgI', array=np.array(indices[:,35]), format='D'),                                           fits.Column(name='Ca1AZ', array=np.array(indices[:,36]), format='D'),                                           fits.Column(name='Ca2AZ', array=np.array(indices[:,37]), format='D'),                                           fits.Column(name='Ca3AZ', array=np.array(indices[:,38]), format='D'),                                           fits.Column(name='CaT', array=np.array(indices[:,39]), format='D'),                                           fits.Column(name='PaT', array=np.array(indices[:,40]), format='D'),                                           fits.Column(name='sCaT', array=np.array(indices[:,41]), format='D')                                           ])    tbhdu.writeto(self.output_dir+'templates_selected_grid_parameters_R2000_sdss_gaia.fits',clobber=True)    print('     > output file done')#############################################################################################################################################  def single_star(self,pars_star,pars_lims):      print('     > interpolating a single star')    #print('     > testing a star: '+str(pars_star))    ndim = len(pars_star)    dist_temp = np.zeros((self.ntemp,ndim))    ##### quality checks #####    template_quality = 0    dist_temp[:,0] = np.abs(pars_star[0]-self.templates_parameters[:,0])    dist_temp[:,1] = np.abs(pars_star[1]-self.templates_parameters[:,1])    dist_temp[:,2] = np.abs(pars_star[2]-self.templates_parameters[:,2])    good = np.where((dist_temp[:,0] <= pars_lims[0]) & (dist_temp[:,1] <= pars_lims[1]) & (dist_temp[:,2] <= pars_lims[2]))[0]    if len(good)>=1:      template_quality = 1          #print('     > quality= '+str(template_quality))            ##### find the 8 vertices for interpolation #####    vertices,vals = self.get_qb(*pars_star)          ##### tri-linear interpolation #####    for dim in xrange(ndim):      vtx_delta = 2**(ndim - dim - 1)      for vtx in xrange(vtx_delta):        vals[vtx,:] += ((vals[vtx+vtx_delta,:]-vals[vtx,:])*(pars_star[dim]-vertices[vtx,dim])/(vertices[vtx+vtx_delta,dim]-vertices[vtx,dim]))    ##### need to transpose the values #####    flux_per_pixel = vals[:,0]     bad_flux = np.isnan(flux_per_pixel) | np.isinf(flux_per_pixel) | (flux_per_pixel <= 0.0)    flux_per_pixel[bad_flux] = 0.0    return self.wave,flux_per_pixel,template_quality#############################################################################################################################################